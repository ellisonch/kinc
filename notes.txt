Free state and counts to 0

Why new so high

Not really using cap

What happens to labels

Can args be part of K structure one less pointer
-- yes, but then not flexible enough to deal with different kinds of lists

Cap of powers od 2 only

Pre in it garbage
-- doesn't seem to help at n = 10000

Function to turn cap into nth in series 1 2 4 8 12 16 20 etc

Since usually there is garbage left, only if at sentinel at bottom of garbage

If k had its own list pointer, could hold next k garbage and get next quick

Alloc mem in blocks and don't free

No sharing btw cells might help concurrency 

DO NOT MUTATE PERMANANT TSTUFF

get the k
set its arguments
init it



need nicer way to rep config inside of c

things are getting decremented before being used

need decs if things come back different



<k> lookup X => Y ...</k>
<env> E X |-> L </env>
<mem> M L |-> Y </mem>

match top k to lookup
k.0 read X
env read E
env read X
env.X read L
mem read M
mem read L
mem.L read Y

--

<threads>
	<k> join ~> K1 </k>
	<k> join ~> K2 </k>
...</threads>

threads.k[I1] read K1 where i1 matches
threads.k[I2] read K2 where i2 matches


Necessary:
- major/more difficult
-- automate optimizations [2 wk]
-- generalize matching so it really works with multiple cells [2 wk]
-- make maps work appropriately [1 wk]
-- handle non-left-linear rules [1 wk]
-- add side conditions (no rewriting; functions okay) [0.5 wk]
-- another optimization pass [_ wk]

- minor/less difficult
-- add .Identities on LHS and RHS [0.5wk]
-- allow maps that contain things other than strings as key [1 wk]
-- pretty much all the builtins (int, float, bags, etc) [1 wk]
-- add functions (can only appear on rhs and in side conditions unless being defined) [1 wk]
-- more comprehensive way of allowing command line args [1 wk]

Optional:
- handle sister-rewrites in lists a, b, (c => d), e, (f => g)
- handle matching lists at beginning of context
- handle matching lists in middle of context
- split up kra and listk (or, change definition to wrap manually)
- more complex "types" (e.g., something is a Result if it's shaped like tv(X, T) and T is a Type)
- allow injection of maps/bags/sets into KLabels, with matching inside

For concurrency:
- handle multiplicity > 1 cells
- actually make execution concurrent